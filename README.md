# QMtibbaR

## RabbitMQ知识点
RabbitMQ是一个由erlang开发的AMQP的开源实现。
> AMQP(Advanced Message Queuing Protocol).高级消息队列协议:
它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。

### RabbitMQ的优势：
- **可靠性(Reliablity)：** 使用了一些机制来保证可靠性，比如持久化、传输确认、发布确认。
-  **灵活的路由(Flexible Routing)：** 在消息进入队列之前，通过Exchange来路由消息。对于典型的路由功能，Rabbit已经提供了一些内置的Exchange来实现。针对更复杂的路由功能，可以将多个Exchange绑定在一起，也通过插件机制实现自己的Exchange。
-  **消息集群(Clustering)：** 多个RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。
-  **高可用(Highly Avaliable Queues)：** 队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。
-  **多种协议(Multi-protocol)：** 支持多种消息队列协议，如STOMP、MQTT等。
-  **多种语言客户端(Many Clients)：** 几乎支持所有常用语言，比如Java、.NET、Ruby等。
-  **管理界面(Management UI)：** 提供了易用的用户界面，使得用户可以监控和管理消息Broker的许多方面。
-  **跟踪机制(Tracing)：** 如果消息异常，RabbitMQ提供了消息的跟踪机制，使用者可以找出发生了什么。
-  **插件机制(Plugin System)：** 提供了许多插件，来从多方面进行扩展，也可以编辑自己的插件。


### RabbitMQ的整体架构
### RabbitMQ各组件功能
- **Broker：** 标识消息队列服务器实体。
- **Virtual Host：** 虚拟主机。标识一批交换机、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制。vhost是AMQP概念的基础，必须在链接时指定，RabbitMQ默认的vhost是 /。
- **Exchange：** 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。
- **Queue：** 消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。
- **Banding：** 绑定，用于消息队列和交换机之间的关联。一个绑定就是基于路由键将交换机和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。
- **Channel：** 信道，多路复用连接中的一条独立的双向数据流通道。新到是建立在真实的TCP连接内地虚拟链接，AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说，建立和销毁TCP都是非常昂贵的开销，所以引入了信道的概念，以复用一条TCP连接。
- **Connection：** 网络连接，比如一个TCP连接。
- **Publisher：** 消息的生产者，也是一个向交换器发布消息的客户端应用程序。
- **Consumer：** 消息的消费者，表示一个从一个消息队列中取得消息的客户端应用程序。
- **Message：** 消息，消息是不具名的，它是由消息头和消息体组成。消息体是不透明的，而消息头则是由一系列的可选属性组成，这些属性包括routing-key(路由键)、priority(优先级)、delivery-mode(消息可能需要持久性存储[消息的路由模式])等。


### RabbitMQ的多种Exchange类型
> Exchange分发消息时，根据类型的不同分发策略有区别。目前共四种类型：direct、fanout、topic、headers(headers匹配AMQP消息的header而不是路由键(Routing-key)，此外headers交换器和direct交换器完全一致，但是性能差了很多，目前几乎用不到了)。

#### direct
消息中的路由键(routing key)如果和Binding中的binding key一致，交换器就将消息发到对应的队列中。路由键与队列名完全匹配。

#### fanout
每个发到fanout类型交换器的消息都会分到所有绑定的队列上去。fanout交换器不处理该路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout类型转发消息是最快的。

#### topic
topic交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键(routing-key)和绑定键(bingding-key)的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符："#"和"*"。#匹配0个或多个单词，*匹配不多不少一个单词。

#### headers
Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。

***  

### TTL
TTL(Time To Live)：生存时间。RabbitMQ支持消息的过期时间，一共有两种。

- 在消息发送时可以进行指定。通过配置消息体的properties，可以指定当前消息的过期时间。
- 在创建Exchange时可进行指定。从进入消息队列开始计算，只要超过了队列的超时时间配置，那么消息会自动清除。


### 死信队列DLX
**死信队列(DLX Dead-Letter-Exchange)：** 利用DLX，当消息在一个队列中变成死信(dead message)之后，它能被重新publish到另一个Exchange，这个Exchange就是DLX。<br>
DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。<br>
当这个队列中有死信时，RabbitMQ就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列。<br>
可以监听这个队列中消息做相应的处理，这个特性可以弥补RabbitMQ3.0之前支持的immediate参数的功能。

**消息变成死信的几种情况：** 
- 消息被拒绝(basic.reject/basic.nack)并且requeue=false
- 消息TTL过期
- 队列达到最大长度


***
### 如何保证高可用？
RabbitMQ的高可用性（不是分布式，只是集群，高可用）
1. **单机模式**
  > demo级别，生产不会用
2. **普通集群模式**
  > 在多台机器上启动多个RabbitMQ实例，每个机器启动一个。创建的queque指挥放在一个rabbitmq实例上，每个实例都去同步queue的元数据。消费的时候，如果连接到了另外的实例，需要去queue所在实例上拉去数据。
  
  > 此方式要么随机连接一个实例拉取数据，要么固定连接queue所在实例。前者有拉取数据的开销，后者导致单实例性能瓶颈。如果存放queue的实例宕机了，会导致其他实例无法拉取其数据；开启消息持久化，等恢复了才能继续拉取。这种方案主要还是提高吞吐量。
3. **镜像集群模式** （高可用模式）
  > 与普通集群不同的是，创建的queue，无论是元数据还是queue的消息都会存在于多个实例上，写到queue的时候，都会自动把消息同步到多个实例的queue里面。

  > 好处在于一个机器宕机了，其他的都可以用。<br>
  > 坏处是：
     1）性能开销大，网络带宽压力和消耗很重。 <br>
     2）扩展性差，一个queue负载重，其他新增机器也包含了此queue的数据，没法线性扩展。




### 如何保证消息的顺序性？
1. RabbitMQ：一个queue，多个consumer，顺序会错乱
2. Kafka：一个topic，一个partition，一个consumer，内部多线程，顺序也会乱。

> 1. RabbitMQ，拆分多个queue，每个queue一个consumer；或者是一个queue对应一个consumer，这个consumer内部用内存队列排队，然后分发给底层不同的worker来处理。
> 2. Kafka：一个topoc一个partition，一个consumer，内部单线程消费，写N个内存queue，然后N个线程分别消费一个queue即可。

### 如何保证幂等性？
消费端实现幂等性，就意味着我们的消息永远不会消费多次，即使我们收到了多条一样的信息。
- 唯一ID+指纹码机制，利用数据库主键去重
- 利用redis的原子性去实现

### 如何保证可靠性？
1. **生产者挂。** 生产者写消息的过程中，消息还没有写到RabbitMQ，在网络传输的过程中就丢了；或是消息到了MQ，但是内部出错没有保存下来。
2. **MQ挂。** MQ接到消息之后先暂存在自己的内存里，消费者还没来得及消费，MQ就挂了，导致暂存的数据丢了。
3. **消费者挂。** 消费者消费到了这个消息，但是还没来得及处理就挂了，但是MQ会以为这个消息已经被处理完了。（消费者的autoAck机制，消费到了数据会自动通知MQ已经完成）

##### 1.(1)开启事务，失败可以重发。
> 事务机制是同步的，生产者发送消息会同步阻塞卡住，等待是成功还是失败。会导致生产者发送消息的吞吐量下来。
##### 1.(2)生产者Confirm机制
> 消息的确认，是指生产者投递消息后，如果Broker收到消息，则会给我们生产者一个应答。
生产者进行接受应答，用来确认这条消息是否正常的发送到了Broker，这种方式也是消息的可靠性投递的核心保障。这是异步的模式，发送消息后不会阻塞，可以发送下一条消息。吞吐量会高一些。

> 如何实现Confirm确认消息？
>1. 在channel上开启confirm确认模式：channel.confirmSelect()
>2. 在channel上开启监听：addConfirmListener，监听成功和失败的处理结果，根据具体的结果对消息进行重新发送或记录日志处理等后续操作。

##### 2.开启MQ消息持久化
> 设置持久化有两个步骤(同时设置才可以)
>1. 创建queue时将其设置为持久化，保证MQ持久化queue的元数据，但是不会持久化queue里的数据。
>2. 将消息设置为持久化，此时MQ会将消息持久化到磁盘上。

##### 3.消费者层面关闭autoAck
> 代码中自己实现ack

#### 生产端的可靠性投递
- 保证消息的成功发出
- 保障MQ节点的成功接受
- 发送端收到MQ节点(Broker)确认应答
- 完善消息的补偿机制
#### 解决方案
- 消息落库，对消息状态进行变更。
> 缺点：对数据库有多次操作。不适用于高并发业务。
- 消息的延迟投递，做二次确认，回调检查。
> 拆出一个回调服务。将落库、检查等操作安排至回调服务上。<br>
1：发送者发送信息至MQ，消费者为下游业务方。<br>
 1.1：成功后，作为发送者发送信息至MQ，消费者为回调服务。<br>
 1.1.1 回调服务接受数据后，落库。<br>
 1.2：失败，等待发送者的延时投递信息。<br>
<br>
2、发送者发送延迟投递信息至MQ，消费者为回调服务。<br>
2.1：查库，确认下游服务方消费已成功。<br>
2.2：查库，确认下游服务方消费失败，通过rpc调用发送者的接口重新发送。<br>
<br>
消息发送者发送的两条信息是同时发送的。<br>
减少了对库的操作，同时解耦，保证了性能，不能百分百保证可靠性

***

 

### 消费端如何限流
当海量消息瞬间推送过来，单个客户端无法同时处理那么多数据，严重会导致系统宕机。这时，需要削峰。<br>
RabbitMQ提供了一种qos(服务质量保证)功能。即在**非自动确认消息的前提下** (非ACK)，如果一定数目的消息(通过基于consume或者channel设置qos的值)未被确认前，不进行消费新的消息。
